## Transaction 分类

- 扁平事务（Flat Transactions）

扁平事务是事务类型中最简单的一种。在扁平事务中，所有操作都处于同一层次，由 BEGIN 开始，由 COMMIT 或 ROLLBACK 结束，其间的操作是原子的，要么都执行，要么都回滚

- 带有保存点的扁平事务（Flat Transactions with Savepoints）

除了支持扁平事务支持都操作外，允许在事带保存点的事务在出现系统奔溃时，所有的报错点都将消失，服务重启后事务需要从头开始，而不能从最近都一个保存点继续执行。

注：务都执行过程中回滚到同一事务中较早都一个状态。保存点用来通知系统应该记住事务当前都状态，以便当之后发送错误是，事务能回到保存点当时都状态

- 链事务（Chained Transactions）

链事务可看成带保存点事务的一个变种。链事务在提交一个事务时，释放不需要都数据对象，将必要的处理上下文隐式的传给下一个要开始的事务（原子操作）。与带保存点扁平事务不同的是，链事务只能回滚当前事务。而且链事务还会持有锁只有在 COMMIT 后才会释放

- 嵌套事务（Nested Transactions）

- 分布式事务（Distributed Transactions）

## 事务的隔离性就是根据读写锁来实现的

## MVCC

InnoDB 的 MVCC ，是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列， 一个保存了行的创建时间，一个保存了行的过期时间， 当然存储的并不是实际的时间值，而是系统版本号。

实现思想是通过数据多版本来做到读写分离。从而实现不加锁读进而做到读写并行。

MVCC 在 mysql 中的实现依赖的是 undo log 与 read view

- undo log: undo log 中记录某行数据的多个版本的数据。
- read view: 用来判断当前版本数据的可见性

## 日志

- redo log

mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到 Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。
那么问题来了，如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！
所以引入了 redo log 来记录已成功提交事务的修改信息，并且会把 redo log 持久化到磁盘，系统重启之后在读取 redo log 恢复最新数据（顺序写）。

- undo log

undo log 叫做回滚日志，用于记录数据被修改前的信息。他正好跟前面所说的重做日志所记录的相反，重做日志记录数据被修改后的信息。undo log 主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。

## 事务的实现

重做日志，回滚日志以及锁技术就是实现事务的基础

1. 事务的原子性是通过 undo log 来实现的
2. 事务的持久性性是通过 redo log 来实现的
3. 事务的隔离性是通过 (读写锁+MVCC)来实现的
4. 而事务的终极大 boss 一致性是通过原子性，持久性，隔离性来实现的！！

## 隔离级别锁

- READ UNCOMMITTED

在 READ UNCOMMITTED 隔离级别下，事务中的修改即使还没提交，对其他事务是可见的。事务可以读取未提交的数据，造成脏读。 因为读不会加任何锁，所以写操作在读的过程中修改数据，所以会造成脏读。好处是可以提升并发处理性能，能做到读写并行。 换句话说，读的操作不能排斥写请求。

- READ COMMITTED

一个事务的修改在他提交之前的所有修改，对其他事务都是不可见的。其他事务能读到已提交的修改变化。在很多场景下这种逻辑是可以接受的。 InnoDB 在 READ COMMITTED，使用排它锁,读取数据不加锁而是使用了 MVCC 机制。或者换句话说他采用了读写分离机制。

- 为什么会产生不可重复读？

这跟 READ COMMITTED 级别下的 MVCC 机制有关系，在该隔离级别下每次 select 的时候新生成一个版本号，所以每次 select 的时候读的不是一个副本而是不同的副本。 在每次 select 之间有其他事务更新了我们读取的数据并提交了，那就出现了不可重复读

- REPEATABLE READ(Mysql 默认隔离级别)

在一个事务内的多次读取的结果是一样的。这种级别下可以避免，脏读，不可重复读等查询问题。mysql 有两种机制可以达到这种隔离级别的效果，分别是采用读写锁以及 MVCC。

- 采用读写锁实现：只要没释放读锁，在次读的时候还是可以读到第一次读的数据。
  优点：实现起来简单
  缺点：无法做到读写并行

- 采用 MVCC 实现：因为多次读取只生成一个版本，读到的自然是相同数据。
  优点：读写并行
  缺点：实现的复杂度高
