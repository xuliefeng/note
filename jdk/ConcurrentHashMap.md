# ConcurrentHashMap

ConcurrentHashMap 是一个并发安全的 hash 操作列表。通过 CAS 和 synchronized 一起使用来进行并发的控制支持

- 链表结构转红黑树结构，并不是对应的节点数据长度超过 7 个元素就一定转换成红黑树。还需要判断当前的数组长度是否小于 64，如果小于 64 则优先进行数组扩容操作
- hash 的 index 值计算：length - 1 & hash 。由于 length 是 2 个次方数，所以每个 length 都只会有个 1 存在（二进制）通过减 1 操作，则获得少 1 位的奇数（类似 00001111）由于& 是且运算，所以只有都是 1 都位数才会等于 1 且总是小于等于 length -1 都值

## put 添加元素

- 验证 key 和 value 值，ConcurrentHashMap 不同于（HashMap） 不允许 key 和 value 存在 null 值
- 计算 key 的 hash 值，使用 key 的默认 hashCode 值进行高低位运算之后获得
- 循环进行添加操作

### 初始化数组

1. 判断是否被其它线程初始化完成，已被其它线程初始化则执行退出操作
2. 还没有被其它线程初始化完成，但是其它线程已经在执行初始化操作了，则释放自己线程的优先级。接着自循判断释放被初始化完成
3. 通过 CAS 设置全局初始化状态位，如果获取成功则由当前线程执行初始化流程

### 初始化 hash 节点

1. 判断对应 hash 节几点是否已被初始化，已经被初始化则退出该操作
2. 根据当前传入的 key 和 value 创建对应的 node 节点对象
3. 通过 CAS 方式将创建的节点对象赋值到节点位置，如果赋值成功则直接结束此次添加流程。反之添加失败则表明该节点被其它线程抢先占用了，退出此流程执行正常的数据添加操作流程

### 对应的 hash 节点正在数据迁移

迁移条件

1. 数据已经初始化完成
2. 当前的节点属于迁移中的节点
3. 新的数组不为空

判断当前数组长度计算出的位标记值和全局 sizeCtl 的高 16 位值是否相同，如果不同则表明当前已经扩容完成。

### 正常节点数据添加

1. 通过 synchronized 方式锁定对应的 hash 节点节点对象，如果没有当前节点有其它线程在操作则阻塞等待
2. 判断数组的节点对象是否等于当前操作的节点对象，如果不等则表明数组节点有变动。则放弃此次数据添加进行下一轮的数据添加
3. 判断当前节点的首位元素的 hash 值，如果非负数则表明节点是链表结构执行链表结构数据添加操作。否则则是红黑树结构执行红黑树元素节点添加操作。数据添加完成之后判断是否需要将链表结构转换为红黑树结构
4. 判断当前的 key 之前是否存在，如果存在则直接返回旧 value，否则进行数据的计数加 1 操作

## tryPresize 数组扩容

- 确定扩容后的数组大小，根据当前的数组长度判断是否大于最大数组长度的一半，如果大于则直接扩容到最大容量，否则根据当前的数组长度扩容一倍
- 循环进行扩容操作（sizeCtl >=0 ）表明数组当时不在进行初始化或者数据迁移

### 初始化数组

1. 如果当前数组未初始化则执行初始化操作，类同于添加元素是的数组初始化
2. 如果此次的扩容数量小于等于数组的下次扩容阈值或者数组的长度已大于等于最大的数组长度限制则表明其它线程已经执行了扩容，则直接结束此次阔总操作

### 扩容

判断数组是否有变更，如果又变更则忽略此次操作再次自循执行下一次判断

1.8 中扩容是否应该达到扩容线程上限有 bug，没有进行进行取 sizeCtl 低位判断

1. 计算出旧数组的标记位值，并且左移 16 位（负数）+2 赋值给全局 sizeCtl
2. 计算每个线程需要扩容的数组节点数量，最小 16 个节点
3. 创建转移数组对象
4. 根据数据的节点数以及最小迁移数计算出当前线程需要转移的节点界限，迁移从数据的尾部开始进行迁移
5. 扩容链表结构通过高低位来进行判断迁移，因为数组的长度是 2 的倍数。所以只会有个二进制位才会为 1，其它位都是 0。key 的 hash 如果跟长度进行&元素结果等于 0，则表明该 key 都 hash 在新的长度位为 0 值。所以存在方新数组都低位也就是原有的数组节点，否则放入高节点扩容后的新节点。并且由于计算出了最后一个变动的节点值后面的位一定都是居于低位或者高位，无需再次计算直接可以放入最后的节点对象后面
