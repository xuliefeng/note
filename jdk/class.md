# class 笔记

## 不会触发 Class Load 场景

1. 当在通过子类中调用父类的静态属性字段时，不会触发子类的 Class Load 操作。只会触发被调用父类以及它之上的父类进行 Class Load 操作
2. 定义数据类型时不会触发数组定义类的 Class Load
3. 当调用一个类的静态常量属性字段时，也不会触发该所属类的 Class Load（JVM 的常量传递优化，在类的编译阶段已经将调用类的常量放入到本类中的常量池中）

## Class 静态初始化顺序

Class 类在加载的过程中，会有对其进行 Class 对象的初始化操作[cinit()]。执行的代码主要由 Class 类中的静属性和静态代码块组成。

1. 静态字段和静态代码块的执行顺序按照在源代码中的先后顺序来执行，对于同个属性字段以最后的顺序赋值对象为准。并且位于静态代码之后的静态属性在静态代码块中只能进行赋值操作而不能进行调用操作。
2. 普通类的初始化操作会先对其父类进行初始化操作，只有先执行完父类的初始化才能执行子类的初始化。所以对于同个类型字段和名称的属性字段最终的初始化值已子类的赋值为最终结果。
3. 接口与普通类不用，对于实现类的初始化并不会先初始化接口本身。之后在使用是才会被执行初始化操作。

## Class 类加载器

Class 的加载器（1.8 以前）分为三层结构模式，Bootstarp ClassLoad、Extension ClassLoad、Application ClassLoad。

1. Bootstarp ClassLoad 负责加载 JAVA_HOME/lib 目录下的 jar 包类
2. Extension ClassLoad 负责加载 JAVA_HOME/lib/ext 目录下的 jar 包类
3. Application ClassLoad 负责加载应用程序目录下的 jar 包类

并且 JVM 通过双亲委派的模式来进行类的加载，对于一个类在加载时先交由父类进行加载父类加载不到时才会有自己进行加载。这样可以保证系统级的类不会被第三方随意的修改。

通常时候类型的加载都是通过双亲委派的方式进行加载，但是在 java 的历史上有 3 次破坏双亲委派加载模式的情况。

1. 1.2 版本之前的虚拟机系统，因为双亲委派模式是在 1.2 的版本中被加入
2. JNDI(Java Naming and Directory Interface,Java 命名和目录接口)。JNDI 提供统一的客户端 API，通过不同的访问提供者接口 JNDI 服务供应接口(SPI)的实现，由管理者将 JNDI API 映射为特定的命名服务和目录系统，使得 Java 应用程序可以和这些命名服务和目录服务之间进行交互。由于实现类是由第三方实现不在 lib 目录下，所以 API 对应的 ClassLoad 无法找到对应的类。对于该场景 jvm 通过线上下文类加载器（Thread 里的 contextClassLoad）来进行加载，线程的类加载器在创建时会通过父线程的加载器赋值给自己，并且可以手动设置。如果最后为空时就默认为应用程序的类加载器。这样在加载 SPI 实现类时通过线程加载器来进行具体的实现类，实现了逆向加载
3. OSGI 模块热部署，每个模块中都有自己的一个类加载器。在对给的类进行加载时，对于特定的类不会交与父类进行加载而是分配给特定的类加载器进行加载

## Class 方法栈帧

方法栈帧是 jvm 运行的最小单位，每个线程的执行过程就是对方法栈的执行过程，线程中的最顶部栈帧称为当期栈帧。 方法栈帧由: 局部变量表、操作数栈、动态链接、结果返回等组成。

1. 局部变量表存储方法的参数和方法中分配的局部变量数据，对于非静态方法。变量表中的下标 0 处存储的为当期对象引用，通过 this 进行使用，一个方法的局部变量表大小在编译的过程中已经确定。所以分配的内存大小也已固定
2. 操作数栈，方法执行中需要分配的栈大小也是已经确定的。操作数栈用来进行方法执行过程中的运算
3. 动态链接，每个方法都包含一个指向运行时常量池中该栈帧所属方法都引用。包含这个引用的目的是为了能够支持当期方法的动态链接。当一个方法调用另一个方法时，就是通过常量池中的方法符号引用来进行表示。动态链接的作用就是将符号引用转化为调用方法的直接引用
4. 结果返回，jvm 的方法结果返回分为两种：正常方法调用 return 和异常情况

方法调用不代表方法的执行，方法调用的唯一目标在于确认需要执行的方法版本。java 的方法引用都是在编译或者运行期间才能知道被调用方法的真实地址，对于在编译期间就能确定的地址引用方法都是一些在运行期间不会变动并且一开始就能确定一个唯一版本的方法

对于在编译期间就能确定方法引用地址的方法调用称之为解析。java 中能够在编译期可知，运行期不可变的方法主要有静态方法和私有方法，静态方法主要是跟类相关，而私有方法只能在对象中调用。因此他们都不可能被继承或被其它版本方法重写覆盖，所以它们都适合在类加载阶段进行解析

