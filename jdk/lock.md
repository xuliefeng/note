# Java 中 lock 实现

Java 中的 lock 实现都是基于 aqs（AbstractQueuedSynchronizer）来实现的，主要的实现有 ReentrantLock 和 ReentrantReadWriteLock 两个常用使用类

## ReentrantLock

- 可重入锁

可重入锁是一个排它锁。每个时刻只能有一个线程持有该锁对象，其它线程如果需要获取锁则需要进行等待前一个锁线程的释放之后才能获取。可重入锁有两种模式：公平锁和非公平锁，默认实现非公平锁

### 锁获取流程

非公平锁

1. 非公平锁模式下，在执行锁获取时会认为当前锁没有被获取而尝试获取锁（直接 CAS 方式操作 state 锁状态对象），如果获取成功则将当前锁的持有线程设置为当前获取线程。
2. 获取当前锁状态，如果没有被其它线程持有则尝试获取（同步骤 1 一致）。获取成功则直接退出流程
3. 当前锁已被其它线程持有，并且持有的线程等于当前线程则将锁的持有次数进行叠加，然后退出流程
4. 返回锁获取失败

公平锁

1. 获取当前锁状态，如果当前当前等待获取锁的线程队列空并且锁还没有被其它线程持有则尝试获取（直接 CAS 方式操作 state 锁状态对象），如果获取成功则将当前锁的持有线程设置为当前获取线程。获取成功则直接退出流程
2. 当前锁已被其它线程持有，并且持有的线程等于当前线程则将锁的持有次数进行叠加，然后退出流程
3. 返回锁获取失败

- 锁获取失败，当前线程创建个排它性节点加入锁获取链表结构中。新创建的节点加入链表的 tail 节点的后面

- 链表节点尝试排队获取锁 自循执行锁获取

1. 获取当前等待节点的前驱节点
2. 如果前驱节点等于 head 节点，则直接锁的获取操作。在此步骤非公平锁可能会获取不到锁，被后来的线程抢到，公平锁模式则一定能获取到锁。如果获取锁成功则将当前节点设置为新的 head 节点并且返回中断状态（默认 false）
3. 如果前驱节点非 head 节点或者锁获取失败，则判断前驱节点的等待状态来设置当前节点是否需要进入阻塞状态。默认前驱的节点等待状态为初始化值，则需要将前驱节点设置为等待唤醒状态，然后返回 false 。所以 node 节点又会有一次机会执行锁获取。如果前置节点取消了锁获取等待则循环查找前一个为取消获取操作的前驱节点，直到找到为止。如果再次执行 步骤 1 ，2 还是未获取锁。则返回当前节点需要进入阻塞 true
4. 当前线程进入阻塞状态，等待其它线程唤醒。唤醒之后并且返回当前线程是否已被设置中断状态

### 锁释放流程

释放锁的持有次数

1. 获取锁当前的锁定次数，然后减去此次需要释放的次数
2. 判断当前锁的持有线程是否为当前的操作线程，如果不是则抛出异常
3. 判断此次锁的释放之后是否完全释放了锁的次数，如果结果等于 0（完全释放）则将锁的持有线程置空
4. 更新锁的持有次数
5. 返回锁释放被完成释放

如果锁的次数全部被释放，判断 head 是否存在。head 存在并且等待状态不为默认值则唤醒下一个需要获取锁的节点线程。该过程是一个轮训的过程，应该如果下个线程已经设置了取消锁获取操作则会跳过

## ReentrantReadWriteLock

- 读排它锁

读排它锁包含两个锁对象，共享锁/排它锁。共享锁是个共享锁，多个线程可以同时持有一个共享锁；排它锁是个互斥锁，同个时间只能有一个线程持有排它锁并且排它锁和共享锁互斥

### 排它锁获取流程

1. 获取当前的锁状态和根据锁状态与拍它锁掩码计算出的拍它锁状态值
2. 如果当前锁已被线程持有，但是排它锁未被持有或者持有排它锁的线程非当前线程则退出锁流程返回获取失败。否则当前线程获取排它锁成功（如果获取的次数达到上限则抛出异常信息）
3. 判断当前排它锁模式，如果是公平锁模式则判断当前是否有其它线程在等待，存在其它线程在等待则直接返回获取失败
4. 锁未被获取 CAS 修改当前锁状态值，失败则表明锁被其它线程持有了，无论是共享锁还是排它锁 都返回获取失败
5. 将当前线程设置为锁都拍它锁持有线程

- 锁获取失败，当前线程创建个排它性节点加入锁获取链表结构中。新创建的节点加入链表的 tail 节点的后面

- 链表节点尝试排队获取锁 自循执行锁获取

1. 获取当前等待节点的前驱节点
2. 如果前驱节点等于 head 节点，则直接锁的获取操作。在此步骤非公平锁可能会获取不到锁，被后来的线程抢到，公平锁模式则一定能获取到锁。如果获取锁成功则将当前节点设置为新的 head 节点并且返回中断状态（默认 false）
3. 如果前驱节点非 head 节点或者锁获取失败，则判断前驱节点的等待状态来设置当前节点是否需要进入阻塞状态。默认前驱的节点等待状态为初始化值，则需要将前驱节点设置为等待唤醒状态，然后返回 false 。所以 node 节点又会有一次机会执行锁获取。如果前置节点取消了锁获取等待则循环查找前一个为取消获取操作的前驱节点，直到找到为止。如果再次执行 步骤 1 ，2 还是未获取锁。则返回当前节点需要进入阻塞 true
4. 当前线程进入阻塞状态，等待其它线程唤醒。唤醒之后并且返回当前线程是否已被设置中断状态

### 共享锁获取流程

1. 获取当前的锁状态和根据锁状态与拍它锁掩码计算出的拍它锁状态值
2. 如果当前锁的排它锁已被获取并且持有的线程非当前线程则直接返回获取失败

- 接下来尝试获取共享锁

1. 判断当前共享锁是否需要进行阻塞，公平锁要求锁的排队队列为空；非公平锁则判断是否存在其它线程等待获取锁，并且第一个等待的线程为非排它锁获取模式。如果不满足则获取失败
2. 判断共享锁是否已被过多获取，如果被过多获取则此次则获取失败
3. 3，4 点都满足则直接共享锁获取，如果 cas 获取失败，则表明锁已被其它线程获取修改，此次获取失败
4. 3，4，5 都满足，则判断共享锁是否第一次被获取，如果是则将当前线程设置为排它锁的第一个持有线程。对于当前线程是共享锁的第一个获取线程的情况下对第一个共享锁持有次数进行加 1 操作

尝试获取共享锁失败，则进入完整的共享锁获取流程（自旋获取共享锁）

1. 获取当前的锁状态和根据锁状态与拍它锁掩码计算出的拍它锁状态值
2. 如果当前锁的排它锁已被获取并且持有的线程非当前线程则直接返回获取失败
3. 如果当前共享锁当前线程获取需进行阻塞等待其它线程获取，判断当前共享锁最后一次的获取是否为当前线程，如果不是当前线程则此次获取共享锁失败
4. 尝试获取共享锁，获取成功之后。如果是则将当前线程设置为排它锁的第一个持有线程。对于当前线程是共享锁的第一个获取线程的情况下对第一个共享锁持有次数进行加 1 操作

- 锁获取失败，当前线程创建个共享节点加入锁获取链表结构中。新创建的节点加入链表的 tail 节点的后面

- 链表节点尝试排队获取锁 自循执行锁获取

1. 获取当前等待节点的前驱节点
2. 如果前驱节点等于 head 节点，则直接锁的获取操作。在此步骤非公平锁可能会获取不到锁，被后来的线程抢到，公平锁模式则一定能获取到锁。如果获取锁成功则将当前节点设置为新的 head 节点并且重新设置中断状态（默认 false），并且当前节点下个节点为共享节点时还会唤醒下一个共享节点。由于下个共享节点又会继续唤醒下个节点，之后遇到排它节点位置或者到达链表尾部
3. 如果前驱节点非 head 节点或者锁获取失败，则判断前驱节点的等待状态来设置当前节点是否需要进入阻塞状态。默认前驱的节点等待状态为初始化值，则需要将前驱节点设置为等待唤醒状态，然后返回 false 。所以 node 节点又会有一次机会执行锁获取。如果前置节点取消了锁获取等待则循环查找前一个为取消获取操作的前驱节点，直到找到为止。如果再次执行 步骤 1 ，2 还是未获取锁。则返回当前节点需要进入阻塞 true
4. 当前线程进入阻塞状态，等待其它线程唤醒。唤醒之后并且返回当前线程是否已被设置中断状态

### 共享锁释放流程

1. 判断当前线程是否是共享锁的第一个持有线程，如果是则更新锁对象的第一个共享锁的持有次数，如果最总为 0 时，还会将第一个共享锁的持有线程赋值为 null
2. 获取共享锁的重入次数对象，依次递减。如果最终为 0 则将重入对象从线程上下文对象中移除
3. 减去共享锁的锁定次数，并通过 CAS 方式修改当前锁的状态值。如果最终锁全部被释放（包含派它锁）则返回释放成功否则返回释放失败

## CountDownLatch

CountDownLatch 用来进行线程间的服务调度，只有等所有的线程都完成之后。主线程流程才能往下执行，该服务类内部通过使用 AbstractQueuedSynchronizer 来进行支持实现。通过 AbstractQueuedSynchronizer 的状态量字段来进行判断是否全部完成，初始化时设置需要等待的线程量。主线程通过判断该状态值是否全部被释放，如果没有被释放则进入等待操作。其它线程则每次进行一次线程的释放来进行锁状态值递减，等到状态值等于 0 时，唤醒主线程

## CyclicBarrier

CyclicBarrier 是一个可多次使用的栏栈控制器，不同于 CountDownLatch 的模式。CyclicBarrier 是等待所有的线程都准备完成之后在一起往下执行模式，并且在最后一个线程执行到达操作是会重新还原属性以便下一次继续使用

1. 该类通过 ReentrantLock 进行并发控制，没一个线程执行等待时需要先获取到锁才可以进行。拿到锁之后判断该栏栈是否已经被其它的线程设置为不可用模式，如果已被设置不可用则抛出 BrokenBarrierException 异常信息
2. 并且在执行该操作的过程中发现当前线程已经被设置为中断状态则直接抛出中断异常 InterruptedException 同时还会将该对象设置为不可用状态
3. 持有数量递减，如果此次递减之后值为 0，则表明所有的线程都已就位唤醒其它等待的线程，并且重置该对象以便下一轮使用
4. 如果非最后一个线程执行，会判断当前的操作是否定时等待还是永久等待，根据不同的选择进行不同的等待操作
5. 等待超时或者被唤醒之后，
6. 判断该对象是当前周期是否已不可被使用，如果不可用则判处 BrokenBarrierException 异常
7. 判断是否完成被唤醒模式，该操作只对超时模式有效。永久等待第 6 步骤如果不终结，此步骤一定是正常。如果该对象已经开启下一轮操作则返回该线程的执行顺序值
8. 定时等待线程，如果是因为超时而被唤醒的则将该对象设置为不可用，并抛出超时异常

## Semaphore

Semaphore 是通过共享锁模式来实现信号量控制，通过设定一定的共享信号量值。前面的线程能够获取到该线程，获取不到的线程会进行阻塞等待。等待前置线程释放之后才能获取

## AbstractQueuedSynchronizer

AbstractQueuedSynchronizer 是 juc 同步类中的基础组件，所有的锁获取都是基于该组件实现的

head 节点无线程关联，只是初始化节点链表结构是赋值的一个空线程共享节点
