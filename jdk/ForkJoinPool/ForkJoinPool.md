# 简介

ForkJoinPool 线程池通过将任务队列进行职责划分，并且通过双向队列方式。最大化的使用线程池线程来加快任务的消费，普通添加的任务全部放入到偶数任务队列上并且放入的位置为双向队列的头部位置。

# 任务添加流程

线程池的初始化只会设置必要的参数选项参数，在进行任务的添加过程中需要进行任务队列等结构的初始化和扩容操作。

1. 判断线程池（runState）是否关闭，如果已关闭则执行线程池的终止操作，并且抛出线程池拒绝异常
2. 判断线程池（runState）是否已初始化，没有初始化则进行线程池池的初始化流程。该操作会进行全局并发锁的竞争获取（runState），在取到锁的线程则会再次判断线程池是否为初始化，然后进行线程池的初始化操作。在初始化完之后将线程池的初始化状态进行赋值（runState）并释放全局并发锁
3. 通过当前线程的探测值（probe）和任务数组的长度以及偶数任务队列掩码来确认当前任务需要添加的任务队列，如果对应的任务队列不存在并且当前没有其它线程获取到全局并发锁，则创建新的任务队形并且获取全局并发锁。然后在判断对应的任务队列位置是否还是不存在，如果不存在则将创建的任务队列放入队列数组中随后释放全局并发锁
4. 如果对应的位置的任务队列不存在并且其它线程获取了全局并发锁，则当前的线程会更新线程的探测值。然后进行下一轮的赋值尝试操作
5. 任务队列初始化完成之后，尝试获取该任务队形的并发锁。获取成功则将当前任务赋值到该任务队列的任务数组中。如果对应的任务数组为初始化或者已饱和则进行任务数组的扩容。任务添加完成之后释放该任务队列的并发锁，并且最后唤醒或者创建一个线程来进行任务消费

## 任务队列任务数组扩容

每个任务队列中都包含一个任务数组，该数组存储需要执行的任务对象，任务数组中存在两个下标（base,top）。在扩容时会根据当前的任务数组长度进行扩大一倍（不存在则取默认值），但是如果超过了设置的最大任务数组长度时则会抛出拒绝策略异常

创建完新的任务数组后判断旧数组是否存在或者任务数据不空则需要进行任务的迁移，迁移根据旧任务数组的 base 来进行，当 base 等于 top 时停止。迁移过程中还会将旧数组中的任务数据清空

## 创建/唤醒线程

1. 判断活跃线程数（ctl<0）是否达到上线，如果达到上线则退出此次操作
2. 获取线程池当前的 scanState 值（ctl 低 32 位存储信息），如果当前的 scanState 为设置表明当前线程池没有线程阻塞。则直接退出该操作等待线程消费（如果线程总数未达上限添加一个工作线程）
   2.1 总线程数和活跃线程数都进行+1 操作，判断当前的局部ctl是否和线程池全局ctl是否相同。不相同则重新赋值给局部ctl并判断总线程数是否已达上限和当前线程池未被阻塞
   2.2 局部ctl和全局ctl一致，则获取全局并发锁。获取锁之后判断线程池是否已停止，没有停止则更新线程总数(全局ctl)，无论是否更新最总都要释放全局并发锁。如果线程池已停止退出全部操作
   2.3 线程数添加成功，创建一个工作线程

