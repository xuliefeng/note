# JVM 随笔

## 内存

### 内存分配方式

- 指针碰撞
- 堆内存

### 对象访问

- 句柄访问
  句柄：在 Java 堆中将会划分出一块内存来作为句柄池 reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息

- 直接访问
直接指针访问：Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的就是对象地址

### 常量池

常量池分为三种：Class 文件常量池（静态常量池，方法区运行时常量池），运行时常量池，字符串常量池

- Class 文件常量池：指的是编译生成的字节码结构中的常量池，它存放了编译期间生成的各种字面量和符号引用，被虚拟机加载后存放在方法区的运行时常量池中

- 运行时常量池：运行时常量池是方法区中的一部分，是一块内存区域。运行时常量池不同于文件常量池的一点是，它是一个动态的常量池。例如可以动态的添加字面量常量

- 字符串常量池：字符串常量池是一个全局的性的。也就是 JVM 中只有存在一份字符串常量池

在 jdk1.6（含）之前也是方法区（永久代）的一部分，并且其中存放的是字符串的实例  
在 jdk1.7（含）之后是在堆内存之中，存储的是字符串对象的引用，字符串实例是在堆中  
jdk1.8 已移除永久代，字符串常量池是在本地内存当中，存储的也只是引用

### 优化手段

1. 方法逃逸：对方法的调用优化后，不存在了方法的调用而是将被调用的方法体替换成原有的方法调用。这样一来就可以减少了方法调用的性能开销并且为后续的优化提供了基础
2. 冗余内容替换：对于多次重复的对象属性调用赋值，可以优化成对使用局部变量赋值。减少对象的调用性能开销
3. 复写传播：对于多个变量进行操作，但是多个变量指向的都是同个堆对象。则可以对多变量赋值进行消除
4. 无用代码删除：对于运行过程中对远行结果没有任何影响的代码进行删除。避免不必要的性能开销

### 逃逸分析

一个方法中的对象，通过其是否会被其它方法，线程使用可以定义为该对象的逃逸级别。

1. 为被其它方法/线程使用：为逃逸
2. 被其它方法使用：方法级逃逸
3. 被其它线程使用：线程级逃逸

### 内存模型

Java 的内存模型中将内存分为多层模式。 工作内存 -> 内存交互协议层（不存在，便于理解） -> 主内存

变量的操作都需要经过三层，内存的读取步骤有 3 步。

1. read：作用于主内存中的变量，它把一个变量的值从主内存中传输到 内存交互协议层
2. load：作用于工作内存的变量，它把 read 读取的变量加载到工作内存
3. use：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作

变量的操作都需要经过三层，内存的写入步骤有 3 步。

1. assign：作用于工作内存的变量，它把一个从执行引擎接收的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
2. store：作用于工作内存的变量，它把工作内存中一个变量的值传递到 内存交互协议层，以便后续 write 操作使用
3. write：作用于主内存的变量，它把 store 操作从 内存交互协议层 中得到的变量的值放入到主内存的变量中

变量的 lock 和 unlock 操作，lock 和 unlock 操作的都是主内存中的变量，lock 操作将一个变量标记为线程独占的状态。unlock 把一个线程独占的变量进行是否，只有被 unlock 释放后的变量才可以被其它线程锁定。

- Volatile 的功能主要有两点

1. 内存一致性，每个线程对于被 Volatile 修饰的变量进行查询和写入时都执行操作主内存中的变量。并且要求 read/load 和 store/write 必须时前后相连的操作。
2. 指令的重排序，对于被 Volatile 修饰的变量在进行变量的写入时会插入一个 lock 的操作指令。该指令会禁止 cpu 将其前后的指令进行重排序操作，并且还会让其将告诉缓存中的数据刷入主内存中，而其它的 CPU 的缓存也将被失效处理。

- 可见性内存屏障：加载屏障（Load Barrier）和写入屏障（Store Barrier）

加载屏障的作用是刷新处理器缓存，存储屏障的作用是冲刷处理器缓存。Java 虚拟机会在 MonitorExit（释放锁）对应的机器码指令之前插入一个存储屏障，这就保障了写线程在释放锁之前在临界区中对共享变量所做的更新对读线程的执行处理器来说是可同步的；相应地，Java 虚拟机会在 MonitorEnter（申请锁）对应的机器码指令之后临界区开始之前的地方插入一个加载屏障，这使得读线程的执行处理器能够将写线程对相应共享变量所做的更新从其他处理器同步到该处理器的高速缓存中。

- 有序性内存屏障：获取屏障（AcquireBarrier）和释放屏障（ReleaseBarrier）

获取屏障的使用方式是在一个读操作之后插入该内存屏障，其作用是禁止该读操作与其后的任何读写操作之间进行重排序，这相当与在进行后续操作之前需要获取相应共享数据的所有权。释放屏障的使用方式是在一个写操作前插入该内存屏障，其作用是禁止该写操作与之前的任何读写操作之间进行重排序，这相当于在对于共享数据操作结束后释放所有权。

Volatile 关键字的作用包括：保障可见性、保障有序性和保障 long/double 型变量读写操作的原子性。
写线程对 volatile 变量的写操作会产生类似于释放锁的效果。读线程对 volatile 变量的读操作会产生类似于获得锁的效果。因此，volatile 具有保障有序性和可见性的作用。 对于 volatile 变量的写操作，Java 虚拟机会在该操作之前插入一个释放屏障，并在该操作之后插入一个存储屏障；对于 volatile 变量读操作，Java 虚拟机会在该操作之前插入一个加载屏障（LoadBarrier），并在该操作之后插入一个获取屏障（AcquireBarrier）。

先行原则

1. 程序次序规则（ProgramOrderRule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
2. 管程锁定规则（MonitorLockRule）：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。
3. volatile 变量规则（VolatileVariableRule）：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。
4. 线程启动规则（ThreadStartRule）：Thread 对象的 start()方法先行发生于此线程的每一个动作。
5. 线程终止规则（ThreadTerminationRule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。
6. 线程中断规则（ThreadInterruptionRule）：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread::interrupted()方法检测到是否有中断发生。
7. 对象终结规则（FinalizerRule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize()方法的开始。
8. 传递性（Transitivity）：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。

final

当一个对象被发布到其他线程的时候，该对象的所有 final 字段（实例变量）都是初始化完毕的，即其他线程读取这些字段的时候所读取到的值都是相应字段的初始值（而不是默认值）。而非 final 字段没有这种保障，即这些线程读取该对象的非 final 字段时所读取到的值可能仍然是相应字段的默认值。对于引用型 final 字段，final 关键字还进一步确保该字段所引用的对象已经初始化完毕，即这些线程读取该字段所引用的对象的各个字段时所读取到的值都是相应字段的初始值。
因为 final 修饰的变量不允许进行排序到对象赋值给变量之后，必须在变量对象赋值给对象引用前执行初始化。

### 线程状态

Java 的线程状态分为 6 个

1. New：创建线程后尚未启动的线程处于该状态
2. Runnable：包含操作系统中的 Running 和 Ready 状态，处于此状态的线程可能正常执行也可能正在等待系统给它分配执行时间
3. Waiting：处于这种状态的线程不会分配执行时间，需要等待其它线程显示唤醒
4. Timed Waiting：处于这个状态的线程也不会分配执行时间，不过无须等待其它线程显示唤醒，在一定时间后会有系统自动唤醒
5. Blocked：线程被阻塞，该状态等待状态的区别在与 阻塞 是在等待着获取到一个排它锁，这个事件将在另一个线程获取这个锁的时候发生
6. Terminated：已终止的线程状态

### 锁操作

jdk 1.6 之后升级了内置锁的实现机制，将之前的只有重量锁类型细分为多种类型以提升锁的性能。升级后的锁有自旋锁，轻量锁，偏向锁以及重量锁。其它的还有锁消除以及锁粗化等优化手段

1. 自旋锁：由于内置锁是通过互斥同步来实现，由于互斥同步对性能影响最大的地方在与阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成。而在实际的过程中锁定状态都只会持续一个很短的时间，为来这段时间去挂起和恢复线程并不值得。1.4 之后 jdk 提供自旋锁模式，固件自循环一定数量来进行等待前置锁释放。1.6 之后加入来自适应自旋锁模式，虚拟机会根据该线程对与锁对获取情况和当前锁对象的线程运行状态自动的设置自循环的次数。
2. 轻量锁：java 所有的对象中都有一个头信息（Mark Word），里面可以标记当前对象的锁状态（01 未锁定，00 轻量锁，10 重量锁）。线程在进入同步代码块是先查看当前对象是否未被锁定（01）,虚拟机会在当前线程中创建一个锁记录（Lock Record）的空间，用于存储锁对象的 Mark Word 的拷贝。然后虚拟机通过 CAS 操作尝试把对象的 Mark Word 更新为指向 Lock Record 的指针。如果这个更新成功，即表明该线程拥有了该对象的锁，并且对象的 Mark Word 的锁标志位将更新为 "00"。如果更新失败则意味着至少有一个线程与当前线程竞争获取该对象的锁。会检查对象的 Mark Word 是否执行当前线程栈帧，如果是则当前线程已经拥有了这个对象的锁，直接进入同步代码。一个锁如果存在被两条以上的线程竞争同一个锁的时候，轻量锁就不再有效，必须升级为重量锁，锁标志位更新为 "10"，此时 Mark Word 中存储的就是执行重量锁（互斥量）的指针，后面等待的线程必须进去阻塞状态。释放是将对象的 Mark Word 和线程中的赋值 Mark Word 对象互换，如果成功则同步顺利完成；如果失败则表明有其它线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程
