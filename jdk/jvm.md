# JVM 随笔

## 内存

### 内存分配方式

- 指针碰撞
  堆内存

### 常量池

常量池分为三种：Class 文件常量池（静态常量池，方法区运行时常量池），运行时常量池，字符串常量池

- Class 文件常量池：指的是编译生成的字节码结构中的常量池，它存放了编译期间生成的各种字面量和符号引用，被虚拟机加载后存放在方法区的运行时常量池中

- 运行时常量池：运行时常量池时方法区中的一部分，是一块内存区域。运行时常量池不同于文件常量池的一点是，它是一个动态的常量池。例如可以动态的添加字面量常量

- 字符串常量池：字符串常量池是一个全局的性的。也就是 JVM 中只有存在一份字符串常量池

在 jdk1.6（含）之前也是方法区（永久代）的一部分，并且其中存放的是字符串的实例  
在 jdk1.7（含）之后是在堆内存之中，存储的是字符串对象的引用，字符串实例是在堆中  
jdk1.8 已移除永久代，字符串常量池是在本地内存当中，存储的也只是引用

### 优化手段

1. 方法逃逸：对方法的调用优化后，不存在了方法的调用而是将被调用的方法体替换成原有的方法调用。这样一来就可以减少了方法调用的性能开销并且为后续的优化提供了基础
2. 冗余内容替换：对于多次重复的对象属性调用赋值，可以优化成对使用局部变量赋值。减少对象的调用性能开销
3. 复写传播：对于多个变量进行操作，但是多个变量指向的都是同个堆对象。则可以对多变量赋值进行消除
4. 无用代码删除：对于运行过程中对远行结果没有任何影响的代码进行删除。避免不必要的性能开销

### 逃逸分析

一个方法中的对象，通过其是否会被其它方法，线程使用可以定义为该对象的逃逸级别。

1. 为被其它方法/线程使用：为逃逸
2. 被其它方法使用：方法级逃逸
3. 被其它线程使用：线程级逃逸

### 内存模型

Java 的内存模型中将内存分为多层模式。 工作内存 -> 内存交互协议层（不存在，便于理解） -> 主内存

变量的操作都需要经过三层，内存的读取步骤有 3 步。

1. read：作用于主内存中的变量，它把一个变量的值从主内存中传输到 内存交互协议层
2. load：作用于工作内存的变量，它把 read 读取的变量加载到工作内存
3. use：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作

变量的操作都需要经过三层，内存的写入步骤有 3 步。

1. assign：作用于工作内存的变量，它把一个从执行引擎接收的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
2. store：作用于工作内存的变量，它把工作内存中一个变量的值传递到 内存交互协议层，以便后续 write 操作使用
3. write：作用于主内存的变量，它把 store 操作从 内存交互协议层 中得到的变量的值放入到主内存的变量中

变量的 lock 和 unlock 操作，lock 和 unlock 操作的都是主内存中的变量，lock 操作将一个变量标记为线程独占的状态。unlock 把一个线程独占的变量进行是否，只有被 unlock 释放后的变量才可以被其它线程锁定。

Volatile 的功能主要有两点

1. 内存一致性，每个线程对于被 Volatile 修饰的变量进行查询和写入时都执行操作主内存中的变量。并且要求 read/load 和 store/write 必须时前后相连的操作。
2. 指令的重排序，对于被 Volatile 修饰的变量在进行变量的写入时会插入一个 lock 的操作指令。该指令会禁止 cpu 将其前后的指令进行重排序操作，并且还会让其将告诉缓存中的数据刷入主内存中，而其它的 CPU 的缓存也将被失效处理。

Volatile 的 Java 内存屏障有 4 个，分别对于写入 2 个和读取 2 个

写入操作

1. StoreStore：在一个 Volatile 变量之前插入 StoreStore 类型内存屏障，该内存屏障要求在写入 Volatile 修饰的变量之前将之前的所有其它普通写操作刷入主内存中，并且之前的普通写不能和被 Volatile 修饰的变量进行执行重排序操作。这样就能保障了其它写的可见性。
2. StoreLoad：在一个 Volatile 变量写入之后插入 StoreLoad 类型内存屏障，该内存屏障要求后续存在的 Volatile 变量在执行 store/load 的操作不能跟上面的写操作发生执行重排序操作

读取操作

1. LoadLoad：在被 Volatile 修饰的变量之后插入一个 LoadLoad 类型内存屏障，该内存屏障要去在 Volatile 的变量不能于之后的读取操作发生指令重排序操作
2. LoadStore：在 LoadLoad 之后插入一个 LoadStore 类型内存屏障，该内存屏障要去后续的普通写或者 Volatile 写不能于之前的 Volatile 读发生指令重排序操作
