- 方法内联
- 逃逸分析

Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。

在方法中创建对象之后，如果这个对象除了在方法体中还在其它地方被引用了，此时如果方法执行完毕，由于该对象有被引用，所以 GC 有可能是无法立即回收的，此时便成为 **内存逃逸现象**

- 逃逸状态
  一个对象有三种逃逸状态：

1. 全局逃逸（GlobalEscape）：即一个对象的作用范围逃出了当前方法或者当前线程，
   一般有以下几种场景：
   ① 对象是一个静态变量
   ② 对象是一个已经发生逃逸的对象
   ③ 对象作为当前方法的返回值

2. 参数逃逸（ArgEscape）：即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。
3. 没有逃逸：即方法中的对象没有发生逃逸

- 标量替换
- 公共子表达式消除
- 数组边界检查消除

- 同步消除（锁消除）
  因为同步锁是非常消耗性能的，所以当编译器确定一个对象没有发生逃逸时，它便会移除该对象的同步锁。
